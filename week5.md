<!-- layout: true -->

<!-- class: middle -->

---

<!-- class: center, middle, inverse -->

# MTE 241 Tutorial

.invisible-slide-comment[See [README](./README.md) to turn this markdown to a slide presentation]

## Stack & Registers

Presented by Huanyi Chen

huanyi.chen@uwaterloo.ca

---

## Roadmap

- We will use https://godbolt.org to explore assembly code and talk about stack
  and registers

- Q&A

---

# Compiler Explorer

Compiler Explorer (<https://godbolt.org>), commonly referred to as "Godbolt"
after its creator Matt Godbolt, is a free, web-based tool that allows developers
to write code in various programming languages and instantly see the
corresponding assembly output generated by different compilers.

We will use it for exploring the assembly code from C code using the ARM GCC
compiler.

---

```c
extern void myfunction(int, int);

void main() {
    myfunction(1, 2);
}
```

--

```assembly
main:
        push    {r7, lr}
        add     r7, sp, #0
        movs    r1, #2
        movs    r0, #1
        bl      myfunction
        nop
        pop     {r7, pc}
```

---

```c
extern void myfunction(int, int, int, int, int);

void main() {
    myfunction(1, 2, 3, 4, 5);
}
```

--

```assembly
main:
        push    {r7, lr}
        sub     sp, sp, #8
        add     r7, sp, #8
        movs    r3, #5
        str     r3, [sp]
        movs    r3, #4
        movs    r2, #3
        movs    r1, #2
        movs    r0, #1
        bl      myfunction
        nop
        mov     sp, r7
        pop     {r7, pc}
```

---

```c
extern void myfunction();

void main(void) {
    __asm (
        "mov r0,  #0xA\n"
        "mov r1,  #0xA\n"
        "mov r2,  #0xA\n"
        "mov r3,  #0xA\n"
        "mov r4,  #0xA\n"
        "mov r5,  #0xA\n"
        "mov r6,  #0xA\n"
        "mov r7,  #0xA\n"
        "mov r8,  #0xA\n"
        "mov r9,  #0xA\n"
        "mov r10, #0xA\n"
        "mov r11, #0xA\n"
    );

    myfunction();
}
```

---

Without any optimization (default):

```assembly
main:
        push    {r7, lr}
        add     r7, sp, #0
        mov r0,  #0xA
        mov r1,  #0xA
        mov r2,  #0xA
        mov r3,  #0xA
        mov r4,  #0xA
        mov r5,  #0xA
        mov r6,  #0xA
        mov r7,  #0xA
        mov r8,  #0xA
        mov r9,  #0xA
        mov r10, #0xA
        mov r11, #0xA

        bl      myfunction
        nop
        pop     {r7, pc}
```

---

With optimization (`-O1` or `-fomit-frame-pointer`):

```assembly
main:
        push    {r3, lr}
        mov r0,  #0xA
        mov r1,  #0xA
        mov r2,  #0xA
        mov r3,  #0xA
        mov r4,  #0xA
        mov r5,  #0xA
        mov r6,  #0xA
        mov r7,  #0xA
        mov r8,  #0xA
        mov r9,  #0xA
        mov r10, #0xA
        mov r11, #0xA

        bl      myfunction
        pop     {r3, pc}
```

---

## Revisit practice questions

---

You've set up the thread stack so that xPSR and PC contain the correct values,
and the remaining registers contain the value `0xA`. You run your code and your
thread prints to UART a few times before you stop it and examine the registers
using the debugger. You notice that almost all registers still hold the value
`0xA`, but `R7` does not. What happened?

---

Switching between MSP and PSP (TODO)

